#  Typescript基础
[toc]
TS 相比 JS 增加了如下内容：
* Types（类型系统）
* next-gen JS Features（js新特性）
* New Features like Interface or Generics (ts特有特性，如接口，泛型)
* Meta-Programming Features like Decorators (泛型)
* Rich Configuration (更多配置)
* Modern Tooling（更智能的编辑器）


## 安装和使用
* 安装：`npm i typescript -g`
* 使用文件：`tsc hello.ts`
* 初始化项目 `tsc --init` 会生成 *tsconfig.json* 



## 数据类型
js的类型分为两种：*原始数据类型*，*对象类型* 
* 原始数据类型包括：`boolean`, `number`, `string`, `null`, `undefined`, `Symbol`, `BigInt`
* 对象类型：`Array`, `Function`, `Date`, `RegExg`

**TS 对 JS 的类型进行拓展**
增加了 `Tuple | Enum | unknown | any | never | void | ` 等概念



### `Tuple`
数组合并了相同类型的对象，**元组** 合并了不同类型的对象。 元组的长度是有限的，可枚举的
```typescript
const gdz: [string, number, number] = ['耿德洲', 25, 170];
```
* 声明的时候，前面定义的类型和后面的值类型要对应上
* 添加新元素时，其类型为元组中每个类型的联合类型。 <small>在上面的示例中，新增的元素，类型将是：`string | number`</small>
* 元组元素可以是可选的。 <small>需要的时候再深入了解</small>



### `Enum`
使用关键字 `enmu` 定义枚举类型。
枚举默认是 *数字类型枚举* 其值默认从 `0` 开始，步长为 `1`。

定义 Enum 的命名规范如下： 
```ts
// 大驼峰
enum StatusCode {
  // 大驼峰
  Success = '200',
  Fail = '1',
}
```



#### 普通枚举
```typescript
enum Days { '日', '一', '二', '三', '四', '五', '六' };
const showDateInfo = () => {
  const date = new Date().getDay();
  return `今天是星期${Days[date]}`;
}
consoleLog(showDateInfo())
```



##### 字符串枚举
```typescript
enum StatusCode {
  Success = '200',
  Fail = '1',
}

enum FormState {
  FormStateView = 'view',
  FormStateEdit = 'edit',
  FormStateAdd = 'add',
}
```



#### 常量枚举
使用 `const` 修饰符来强调当前枚举类型。
```typescript
// 常量枚举
const enum Month { Jan, Feb, Mar };
const month = [Month.Jan, Month.Feb, Month.Mar];
consoleLog(month)
```



### `unknown`
`unknown` 可以表示任意类型，**任何类型都能分配给 `unknown`，但 `unknown` 不能分配给其他基本类型**，只能赋值给 `any | unknown` 。而 `any` 啥都能分配和被分配。
`unknown` 在使用前必需显示进行指定类型，或者在有条件判断情况下隐式的进行类型推断

啥意思呢？没明白的话，就再写一遍。下面代码中我们有一个 unknown 类型的变量；
* 我们可以把任何类型赋值给它。
* 但是呢，我们不能把其它赋值给其他类型，比如说你把一个 unknown 赋值给 string 会报错的。
```typescript
let data: unknown;
data = true; // ok
data = 2222  // ok

let data2: string = foo // error
```


#### 类型收缩
如果一个类型是 unknown，我们应该确定类型呢？
1. 使用 类型断言 即 `as`
2. 使用 `typeof`
3. 使用 `instanceof`

```typescript
let data: unknown;
data = 2;
data = false;

const consoleData = (data: unknown): void => {
  if (typeof data === "boolean") {
    console.log(`data 是一个 boolean 类型`)
  }
}
consoleData(data);
let data2: boolean = data as boolean;
console.log(data2)
```



### `any`
使用 `any` 表示允许赋值为任意类型。

#### 任意值的属性和方法
使用任意值之后，
1. 可以访问任何属性
2. 可以调用任何方法
3. 任意值进行任何操作，其返回值的类型为任意类型
4. 未声明类型的变量，会被默认声明为任意类型



### 使用说明和示例
```typescript
// boolean
const flag: boolean = false;

// number
const num: number = 20;

// string
const str: string = 'hello';

// null 和 undefined
const u: undefined = undefined;
const n: null = null;

// 这样不会报错
let num: number = undefined;

// void
const showName = (name: string): void => {
  console.log(name)
}

// Tuple 元组
const gdz: [string, number, number] = ['耿德洲', 25, 170];
consoleLog(gdz[0], gdz[1], gdz[2]);
gdz.push('前端工作者');
// gdz.push(false); // 这样会报错
consoleLog(gdz)

```

说明：
1. *undefined* 和 *null* 是所有类型的子类型。也就是说 *undefined* 类型的变量 可以赋值给 *number* 类型的变量 
2. *void* 表示没有任何返回值，只能将其赋值为 *undefined* 或者 *null*
3. 当使用 `--strictNullChecks` 标志时，`null` 和 `undefined` 只能分配给 `unknown`，`any` 以及它们各自的类型。严格类型包括了`--strictNullChecks`，所以也是如此。



## 联合类型、交叉类型

### 联合类型 `|`
联合类型 `|`：**目标值的类型可以为多个类型中的一种**，表示多种类型的 **或** 关系。
`string | number` 就称为联合类型。多个类型间使用 `|` 分割开。


### 交叉类型 `&`
交叉类型 `&`：**表示多种类型的 **与** 关系**
```typescript
interface Person {
  name: string;
  age: number;
}

interface Animal {
  name: string;
  color: string;
}

const x: Person & Animal = {
  name: 'x',
  age: 1,
  color: 'red'
}

```



## 类型别名 `type`
类型别名 `type`：就是 **给联合类型起个别名**。使用关键字 `type`。
还有一种意思是：TS允许自己定义不在基本类型中的类型
比如：`type StringOrNumber = string | number`。

```typescript
// string | number 就称为联合类型、
// StringOrNumber 就是给联合类型起个别名
type StringOrNumber = string | number

// 下面是正常使用
let myNameOrAge : StringOrNumber = 10
myNameOrAge = '小明'
```



### 字符串字面量类型
* 用来约束取值只能是给定的值中的其中一个
* 使用 `type` 进行定义 <small>定义方式和使用方法都和 *类型别名* 相同</small>

```typescript
type OneToFive = 1 | 2 | 3 | 4 | 5;
const a1: OneToFive = 1; // a1 只能是 1-5中的一个
```



### 在 type 中使用泛型
```typescript
type Record<K extends keyof any, T> = {
  [P in K]: T;
};
```



### 像使用函数一样写type
```typescript
type FormEffectSelector = (
  type: LifeCycleTypes,
  matcher?: string
) => Observable<IFieldState>;

type FormEffect<C = unknown> = (
  $: FormEffectSelector,
  actions: ISchemaFormActions,
  context?: C
) => void;

// 这里是像写函数一样，定义高阶类型
type FormEffectCtx<C = unknown> = (context?: C) => FormEffect<C>;

// 使用方式如下
const effects: FormEffectCtx = ({ data }) => ($, action) => {
  // ....
}
```




## 类型推导
如果没有明确的指定类型，那么ts会依照类型推导的规则推断出一个类型
这是 ts 内部帮我们做的东西，可以帮我们解释为什么我没写类型没报错

示例
```typescript
let age = 24;
age = 'six';
// 会报错。类型推导age为number，手动赋值为string。这时候就会报错

let age;
age = 24;
age = 'six';
// 不会报错。未声明类型的变量，会被默认声明为任意类型，任意类型可以进行任意操作，然后得到任意值。

```



## 类型断言
手动指定一个值的类型。

### 两种写法
* `<类型>值` 
* `值 as 类型` --> 在tsx中必须使用这种类型

可以统一使用 `值 as 类型`这种方式。



### 使用场景
多在 `if 语句` 中使用。 <small>如果是其中一个类型，就执行某些操作。</small>
* 将一个联合类型断言为其中的一个类型
* 将父类断言为更具体的子类
* 将任何一个类型断言为 *any*
* 将any断言为一个具体的类型

```typescript
function getLength(something: string | number): number {
    if ((<string>something).length) {
        return (<string>something).length;
    } else {
        return something.toString().length;
    }
}
```

```typescript
export default { name: gdz, age: 25 } as PersonProfile
```
