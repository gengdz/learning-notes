# IOC 和 DI

## 什么是IOC
IOC（Inversion of Control) 翻译为：**控制反转** 或者 **依赖倒置**。主要包含下面三个准则：
1. 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象
2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象
3. 面向接口编程而不是面向实现编程

一些理解
控制：对对象的控制权，如创建和销毁
反转：由最初在类中手动创建对象反转为由Spring容器去创建

高层按照需要定义接口，底层按照高层定义的接口实现接口。 接口只是依赖倒置的实现方法之一

> * [前端中IOC概念](https://zhuanlan.zhihu.com/p/53832991)


## DI
DI(Dependency Injection) 依赖注入
简单说来就是把高模块所依赖的模块，通过一定的方式，把依赖注入到模块内部



## IOC和DI的关系
IOC是指导思想，DI是这个这个指导思想下的实践。


## 在React中的运用

### 组合服务
服务A: useFuncA.
服务B: useFuncB.
服务组合就是 我们在A中使用B的逻辑。即在A中，调用 useFuncB()

为什么要用useFunc，不直接import数据和方法?
因为需要框架内的响应式能力，这个叫控制反转，框架将响应式的控制权转交给了开发者
什么时候调用，什么时候更新视图的控制权也在框架甚至直接是组件节点手上，但是会通过各种 hooks api 反转给你，你就能将这些东西定义在任何文件任何useFunc中。
你对比class老版本，控制权没有反转时，你是不是状态和更新必须调用this上的api？那么这部分逻辑提取成服务就不可能办到。

反转指的是，很多时候问题的根源在于，react没有把变更和相应式的控制权给我我们我们。框架系统把内部逻辑的控制权给到开发者，就是控制反转。
useState 响应控制权
useEffect m-vm的响应式回调
useLayoutEffect vm-v的响应式回调
useMemo 调度控制权



### 注入单例服务
如果需要注入单例服务应该怎么办?
**单例需要注入到唯一节点，因此，可以在所有需要用到这个服务的组件的最外层注入。**

* 直接在 jsx 的 provider 种 value = {useSomeService()} 在本组件没有任何其它响应式变量的情况下是可行的，因为不会重新初始化，在良好的架构下——组件除注入，无任何逻辑，return 之前没有东西，同时，上下文单独封装组件，可以作为“模块标识”
* 这个有共同单例 Service 的一系列组件，被称为**模块**，它们有自己的“限界上下文”，并且，视图，逻辑，样式都在其中，如果这个模块是按照功能划分的，那么这种 SOA 实现被称为 领域驱动设计(DDD) ，某些架构强推的所谓'微前端'，目的就是得到这个东西
* 一定要注意，这个模块的上层数据变更，模块的限界上下文会刷新，这个是默认操作，这也是为何 jsx直接赋值 的原因，如果你不需要这个东西，可以采用 const value = useServce() 包裹，或者直接 memo 这个模块标识组件


### 深层嵌套对象问题
类似于：需要很深层级的组件中，修改上层的逻辑。
解决方案：通过单例服务注入的方式。

* 不用担心纯度和不变性的问题，因为hooks都是纯的，没有不纯的情况。
* 全局副作用是状态+函数全局逻辑封装（分层）考虑的问题，将函数和组件，视图功能逻辑样式全部作为模块，副作用是以模块为单位的，而info和setInfo的getter，setter封装，叫做——模块间通讯
* 在这里props的功能好像只有 ‘分形’，也就是map中将数据的标示传递给子组件，是的 —— 优先使用服务共享状态逻辑





### 可选服务
模块服务划分的另一个巨大优势，就是将逻辑变为可选项，这在重型应用中，几乎就是采用DDD的关键先生
可选服务就是将逻辑变为可选项，
```javascript
function useServiceByOneLogic(){
  return {
    activated,
    // ...
  }
}
function useServiceByAnotherLogic(){
  return {
    activated,
    // ...
  }
}
function useSomeService(){
  const [...servicList] = [useServiceByOneLogic(),useServiceByAnotherLogic()]
  // 选择激活的服务
  const usedService = useMemo(()=>{
    for(let serivce of serviceList){
      if(service.activated === true){
        return service
      }
    }
  },[serviceList])
  return service
}
// 注入过程省略...

```
* 你也可以通过各种条件筛选服务，这种方式是在前端实现的高可用
* 注意，服务最好只是内部实现不同，接口应该尽可能相同，否者会出现可选类型
* 还有一个非常有意思的方案，通过服务来做数据 mock，因为服务直接对接视图，你只需要模拟视图数据即可，提供两个服务，一个真实服务，一个mock服务，这样是用真实数据还是mock数据，都是服务自动判断的，对你来说没有流程差别


### 按照功能划分文件结构
作为一个功能，逻辑，视图，样式，请求等等所有组成部分，应该是一个完整的，不可分割的整体，你才能像搭积木一样工程化地运用它。
如果将其拆开，调试困难，追踪困难的问题，以上提到的可选服务，简单处理嵌套结构都全不成为了不可能
同时，不利于分工合作
每个人都在各自模块下，处理各自问题，顶层组着者再在高层及模块下，将他们组合起来，这是工程化的最优解，这也是 DDD 的核心目标



### 有了IOC之后，props的作用是什么呢？
除了影响调度（函数式组件）外，props其实在新版React中，**只起到 map 节点传递 迭代标示 或者 注入令牌的作用**




## 一些东西
调度。
函数是运行时的结构，如果没有利用模式匹配，每次函数执行只有一个结果，那么整个串行函数管道的返回也只会有一个结果如果利用了呢？它将会向路牌一样，指示着逻辑倒流到特定的lamda函数中，形成分形结构请注意，这个分形结构不只是空间上的，还有时间上的。
这，就是调度！！！

Hooks api 就是 React 的调度控制权
React 将它的调度控制权，拱手交到了用户手上，这就是hooks。
* useState 整个单项数据流的调度发起者
* useEffect 整个单项数据流调度的指挥者
useEffect 是分形指示器，在 rxjs中被称为 operators,将你的部分变更，衍射到另一处变更。在这个api中，大量模式匹配得以正常工作
* useMemo 整个单项数据流调度的控制者




