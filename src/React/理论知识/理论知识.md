# React 理论知识

`UI = F(state)`

React 是 Facebook 推出的一个**用于构建用户界面的 JaveScript 库**

React 底层架构可以简化成为三步：

1. 用户交互产生 `update`。比如：点击事件
2. `state = reconcile(update)`。也就是我们俗称的 diff 算法
3. `UI = commit(state)`

## React 组件更新的流程

1. **创建更新**创建一个 Update 对象，并把这个更新对象放在该组件对应的 Fiber 节点的**更新队列** updateQueue 中，Fiber 节点标记为需要更新
   - Update 对象包含了 新的状态值，更新的优先级、回调函数等。
2. **调度更新**：React Scheduler 根据任务的优先级来决定什么时候处理这个更新
3. **Render 阶段**（Render Phase）：React 根据最新的 props 和 state 重调组件的 render 方法，生成新的 React 元素，并根据这些元素构建新的 Fiber 树。这个过程可被中断以确保高优先级任务能及时响应
4. **协调阶段**（Reconciliation）：对新旧两棵 Fiber 树进行对比，计算出需要变化 Fiber 节点，把他们会放在 Effect List 链表中，并准备进行这些更新。
5. **提交阶段**（Commit Phase）：将 Reconciliation 阶段确定的更新应用到 DOM 上，并执行相关的钩子和生命周期方法，这个阶段是同步且不能中断的。
6. **清理和回调**：清理副作用，执行回调函数。在所有 DOM 更新完成、相关生命周期方法和 Hooks 调用之后，如果有挂起的回调函数（比如 setState 的回调参数），它们也会在这个时候被调用。更新流程现在完成，组件反映了新的状态

## Reconciliation

Diff 的过程

1. 从根 Fiber 节点开始
2. 逐层比较 Fiber 节点，先比较**类型**，如果类型相同，那么将会复用节点，更新 props，如果类型不同，销毁子树并构建新的Fiber子树
3. key的匹配：对于拥有多个子节点的组件，React会使用key属性来标识子节点，以确定哪些子节点在不同的渲染中保持不变。这对于列表和数组中的元素尤其重要。
4. 处理节点类型不同的情况：如果新旧Fiber节点的类型不一致，React会销毁旧的Fiber节点及其子节点，并创建新的Fiber节点。
5. 生成Effect List：对比过程中确定的所有变更（插入、更新、移动、删除）都会记录在Effect List中。这个列表稍后会在Commit阶段用来应用这些变化到实际的DOM上。
6. 一直到没有子节点：Diff过程会继续，直到新的Fiber树完全构建完成，所有层级的差异检测都完成。

因为在每一次进行比较的时候，都会看浏览器是否有空闲时间，如果有就执行，如果没有就不执行。所以这就是可中断的，采用的是链表，所以知道再哪里恢复。这个过程称为“可中断渲染”或“增量渲染”。

## 受控组件和非受控组件

受控组件是指：组件的改变，完全受控于数据的变化，数据变化了页面就变化了。

非受控组件是指：直接操作 DOM，不做数据的绑定，然后通过 ref 直接去取 DOM 上的内容。

代码示例受控组件

```javascript
// 受控组件
<input value={value} onChange={onValueChange} />
```

非受控组件

```javascript
// 非受控组件 可以在 Input 组件里面输入任意内容，然后通过 ref 获取里面的值
<input ref />
```

## 事件的 this 指向

- 箭头函数

原理是：箭头函数没有 this, 他就会往上找，找到类的 this，也就是组件本身。

- bind 一般在 constructor 中，做 bind 的绑定，这样可以使函数的引用保持一份，避免引用改变带来的无谓渲染。

## 异步组件（按需加载）

场景是： 当你整个项目打包之后，最后的代码文件很大。这时候，你可能需要按需加载一部分，也就是，当用户访问首页的时候加载首页的代码，当访问这个菜单的时候，加载这个菜单的代码。

相关的库 Reloadable
