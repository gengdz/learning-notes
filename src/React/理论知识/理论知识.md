# React 理论知识

`UI = F(state)`

React 是 Facebook 推出的一个**用于构建用户界面的 JaveScript 库**

React 底层架构可以简化成为三步：

1. 用户交互产生 `update`。比如：点击事件
2. `state = reconcile(update)`。也就是我们俗称的 diff 算法
3. `UI = commit(state)`

## React 组件更新的流程

1. **创建更新**创建一个 Update 对象，并把这个更新对象放在该组件对应的 Fiber 节点的**更新队列** updateQueue 中，Fiber 节点标记为需要更新
   - Update 对象包含了 新的状态值，更新的优先级、回调函数等。
2. **调度更新**：React Scheduler 根据任务的优先级来决定什么时候处理这个更新
3. **Render 阶段**（Render Phase）：React 根据最新的 props 和 state 重调组件的 render 方法，生成新的 React 元素，并根据这些元素构建新的 Fiber 树。这个过程可被中断以确保高优先级任务能及时响应
4. **协调阶段**（Reconciliation）：对新旧两棵 Fiber 树进行对比，计算出需要变化 Fiber 节点，把他们会放在 Effect List 链表中，并准备进行这些更新。这个阶段是可以被中断的。
5. **提交阶段**（Commit Phase）：将 Reconciliation 阶段确定的更新应用到 DOM 上，并执行相关的钩子和生命周期方法，这个阶段是同步且不能中断的。
6. **清理和回调**：清理副作用，执行回调函数。在所有 DOM 更新完成、相关生命周期方法和 Hooks 调用之后，如果有挂起的回调函数（比如 setState 的回调参数），它们也会在这个时候被调用。更新流程现在完成，组件反映了新的状态

## Reconciliation

Diff 的过程

1. 从根 Fiber 节点开始
2. 逐层比较 Fiber 节点，先比较**类型**，如果类型相同，那么将会复用节点，更新 props，如果类型不同，销毁子树并构建新的 Fiber 子树
3. key 的匹配：对于拥有多个子节点的组件，React 会使用 key 属性来标识子节点，以确定哪些子节点在不同的渲染中保持不变。这对于列表和数组中的元素尤其重要。
4. 处理节点类型不同的情况：如果新旧 Fiber 节点的类型不一致，React 会销毁旧的 Fiber 节点及其子节点，并创建新的 Fiber 节点。
5. 生成 Effect List：对比过程中确定的所有变更（插入、更新、移动、删除）都会记录在 Effect List 中。这个列表稍后会在 Commit 阶段用来应用这些变化到实际的 DOM 上。
6. 一直到没有子节点：Diff 过程会继续，直到新的 Fiber 树完全构建完成，所有层级的差异检测都完成。

因为在每一次进行比较的时候，都会看浏览器是否有空闲时间，如果有就执行，如果没有就不执行。所以这就是可中断的，采用的是链表，所以知道再哪里恢复。这个过程称为“可中断渲染”或“增量渲染”。

## React 合成事件

合成事件是对浏览器原生事件的跨浏览器包装。

为什么要做合成事件。

1. 解决浏览器的兼容问题。preventDefault、stopPropagation 等方法在不同浏览器中可能存在差异，React 的合成事件提供了一致的 API。
2. 性能优化。利用事件委托，不直接在 DOM 上绑定事件，而是在 Document 上绑定事件
3. 事件池机制：不需要我们手动的移除事件监听。

## 受控组件和非受控组件

受控组件是指：组件的改变，完全受控于数据的变化，数据变化了页面就变化了。

非受控组件是指：直接操作 DOM，不做数据的绑定，然后通过 ref 直接去取 DOM 上的内容。

代码示例受控组件

```javascript
// 受控组件
<input value={value} onChange={onValueChange} />
```

非受控组件

```javascript
// 非受控组件 可以在 Input 组件里面输入任意内容，然后通过 ref 获取里面的值
<input ref />
```

## 事件的 this 指向

- 箭头函数

原理是：箭头函数没有 this, 他就会往上找，找到类的 this，也就是组件本身。

- bind 一般在 constructor 中，做 bind 的绑定，这样可以使函数的引用保持一份，避免引用改变带来的无谓渲染。

## 异步组件（按需加载）

场景是： 当你整个项目打包之后，最后的代码文件很大。这时候，你可能需要按需加载一部分，也就是，当用户访问首页的时候加载首页的代码，当访问这个菜单的时候，加载这个菜单的代码。

相关的库 Reloadable
