# diff 算法

它的签名应该是这样的: `IVNode -> IVNode -> DOM 操作`

## 设计动机

两棵树对比差异拿到最小操作数的时间复杂度为 O(n<sup>3</sup>)，其中 n 为树中元素的个数

这个代码太大。为了解决这个问题，React 提出了一套 O(n) 的 _启发式算法_

1. 两个不同类型的元素会产生不同的树。(只会比较同级节点，如果不同，那么就不需要去比较子节点了)
2. 开发者可以通过 key 来暗示哪些子元素在不同的渲染下能保持稳定（key 值是同级元素唯一的标识）

## 明确 3 个基础问题

1. 比较两棵树，是哪两棵树?（DOM 树、Fiber 树、ReactElement 树）
   - 是比较两颗 Fiber 树。Fiber 封装 ReactElement 有拓展了其他属性，其中包含了真正的 DOM 信息
2. 比较过程发生在什么时候？(是先生成两颗树，还是别的方式)
   - 边生成边比较。不是先生成再比较。
3. Diff 的结果是什么？
   - 只针对节点的 新增、删除、移动。不包括节点的属性变化，属性的操作是从下到上回溯的过程中发生的。

总结，diff 的过程就是

通过对比 current fiber 节点与新生的 ReactElement 对象，生成新的 Fiber 节点并收集 新增、删除、移动等副作用信息存储在新的 fiber 节点上，等待 commit 阶段处理。

flags, subtreeFlags 就是收集副作用的标记。

- flags 它代表当前 fiber 节点的副作用的标记。
  - 值是在 diff 的过程中进行的副作用标记。
  - 新增/移动 就会在当前的 fiber 节点打上 Placement 的标记
- subtreeFlags 它代表当前节点的所有子 fiber 的 flag 信息。这个值是它在从下往上回溯的时候填充的

## 比较的过程

- **Tree diff**
  将新旧两颗树逐层进行对比，找出哪些节点需要更新
  如果节点是组件，就看 Component diff
  如果节点是标签，就看 Element diff
- **Component diff**
  如果节点是组件，就先看组件类型
  类型不同直接替换（删除旧的）
  类型相同则只更新属性
  然后深入组件做 Tree diff（递归）
- **Element diff**
  如果节点是原生标签，则看标签名
  标签名不同直接替换，相同则只更新属性
  然后进入标签后做 Tree diff（递归)

**永远只比较同层节点**

1. 如果元素类型不相同，那么卸载以该节点为根的树并建立新的树。
2. 如果元素类型相同
   - 都是 DOM 节点，更新 DOM 属性，比如 style。向下递归，对比子元素。
   - 都是组件节点，那么组件实例保持不变，更新 props

遍历子节点列表
如果子节点有 key，那么通过 key 查找元素是否

## Dom diff 的缺点

- 同级节点对比存在 bug
  比如 [1, 2, 3] -> 删除 2 -> [1, 3];
  原因是：首先对比 1 和 1，发现 「1 没变」；然后对比 2 和 3，发现「2 变成了 3」；最后对比 3 和 undefined，发现 「3 被删除了」，然后计算机得出的结论是： 「2 变成了 3」以及 「3 被删除了」。
  这显然不是我们想看到的，怎么解决？
  **加 key**
