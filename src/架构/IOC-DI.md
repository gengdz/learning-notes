# IOC 和 DI

## 什么是IOC

[5种React组件设计模式](https://javascript.plainenglish.io/5-advanced-react-patterns-a6b7624267a6)

> 控制反转：给予使用组件的开发人员的**灵活性**和**控制级别**。

IOC（Inversion of Control) 翻译为：**控制反转** 或者 **依赖倒置**。主要包含下面三个准则：

1. 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。（所以高层模块和底层模块之间应该有一个抽象层。在 TS 中就是 一个 TS 类型）
2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象
3. 面向接口编程而不是面向实现编程

一些理解
控制：对对象的控制权，如创建和销毁
反转：由最初在类中手动创建对象反转为由Spring容器去创建

高层按照需要定义接口，底层按照高层定义的接口实现接口。 接口只是依赖倒置的实现方法之一

> - [前端中IOC概念](https://zhuanlan.zhihu.com/p/53832991)

## DI

> 依赖：是当类需要执行其功能时，所需要的服务或对象。
> 依赖注入既是设计模式，同时又是一种机制：当应用程序的一些部件（即一些依赖）需要另一些部件时， 利用依赖注入来创建被请求的部件，并将它们注入到需要它们的部件中。
> 在 Angular 中，依赖通常是服务，但是也可以是值，比如字符串或函数。
> 应用的注入器（它是在启动期间自动创建的）会使用该服务或值的配置好的提供者来按需实例化这些依赖。各个不同的提供者可以为同一个服务提供不同的实现
> -- Angular

DI(Dependency Injection) 依赖注入
简单说来就是把高模块所依赖的模块，通过一定的方式，把依赖注入到模块内部

## DI 令牌

> 一种用来查阅的令牌，它关联到一个依赖提供者，用于依赖注入系统中。
> 当使用提供者配置注入器时，就会把提供者和一个DI令牌关联起来。注入器维护一个内部**令牌-提供者**的映射表，当请求一个依赖项时就会引用它。令牌就是这个映射表的键。
> 在简单的例子中，依赖项的值是一个实例，而类的类型则充当键来查阅它。 通过把 HeroService 类型作为令牌，你可以直接从注入器中获得一个 HeroService 实例。
> -- Angular

在 React 中 注入令牌就是

```typescript
export const ListService = G.getServiceToken(useListService);
```

## IOC 和 DI 的关系

IOC是指导思想，DI是这个这个指导思想下的实践。

## 在React中的运用

### 组合服务

服务A: useFuncA.
服务B: useFuncB.
服务组合就是 我们在A中使用B的逻辑。即在A中，调用 useFuncB()

为什么要用useFunc，不直接import数据和方法?
因为需要框架内的响应式能力，这个叫控制反转，框架将响应式的控制权转交给了开发者
什么时候调用，什么时候更新视图的控制权也在框架甚至直接是组件节点手上，但是会通过各种 hooks api 反转给你，你就能将这些东西定义在任何文件任何useFunc中。
你对比class老版本，控制权没有反转时，你是不是状态和更新必须调用this上的api？那么这部分逻辑提取成服务就不可能办到。

反转指的是，很多时候问题的根源在于，react没有把变更和相应式的控制权给我我们我们。框架系统把内部逻辑的控制权给到开发者，就是控制反转。
useState 响应控制权
useEffect m-vm的响应式回调
useLayoutEffect vm-v的响应式回调
useMemo 调度控制权

### 注入单例服务

如果需要注入单例服务应该怎么办?
**单例需要注入到唯一节点，因此，可以在所有需要用到这个服务的组件的最外层注入。**

- 直接在 jsx 的 provider 种 value = {useSomeService()} 在本组件没有任何其它响应式变量的情况下是可行的，因为不会重新初始化，在良好的架构下——组件除注入，无任何逻辑，return 之前没有东西，同时，上下文单独封装组件，可以作为“模块标识”
- 这个有共同单例 Service 的一系列组件，被称为**模块**，它们有自己的“限界上下文”，并且，视图，逻辑，样式都在其中，如果这个模块是按照功能划分的，那么这种 SOA 实现被称为 领域驱动设计(DDD) ，某些架构强推的所谓'微前端'，目的就是得到这个东西
- 一定要注意，这个模块的上层数据变更，模块的限界上下文会刷新，这个是默认操作，这也是为何 jsx直接赋值 的原因，如果你不需要这个东西，可以采用 const value = useServce() 包裹，或者直接 memo 这个模块标识组件

### 深层嵌套对象问题

类似于：需要很深层级的组件中，修改上层的逻辑。
解决方案：通过单例服务注入的方式。

- 不用担心纯度和不变性的问题，因为hooks都是纯的，没有不纯的情况。
- 全局副作用是状态+函数全局逻辑封装（分层）考虑的问题，将函数和组件，视图功能逻辑样式全部作为模块，副作用是以模块为单位的，而info和setInfo的getter，setter封装，叫做 —— 模块间通讯
- 在这里props的功能好像只有 ‘分形’，也就是map中将数据的标示传递给子组件，是的 —— 优先使用服务共享状态逻辑

### 可选服务

模块服务划分的另一个巨大优势，就是将逻辑变为可选项，这在重型应用中，几乎就是采用DDD的关键先生
可选服务就是将逻辑变为可选项，

```javascript
function useServiceByOneLogic() {
  return {
    activated,
    // ...
  };
}
function useServiceByAnotherLogic() {
  return {
    activated,
    // ...
  };
}
function useSomeService() {
  const [...servicList] = [useServiceByOneLogic(), useServiceByAnotherLogic()];
  // 选择激活的服务
  const usedService = useMemo(() => {
    for (let serivce of serviceList) {
      if (service.activated === true) {
        return service;
      }
    }
  }, [serviceList]);
  return service;
}
// 注入过程省略...
```

- 你也可以通过各种条件筛选服务，这种方式是在前端实现的高可用
- 注意，服务最好只是内部实现不同，接口应该尽可能相同，否者会出现可选类型
- 还有一个非常有意思的方案，通过服务来做数据 mock，因为服务直接对接视图，你只需要模拟视图数据即可，提供两个服务，一个真实服务，一个mock服务，这样是用真实数据还是mock数据，都是服务自动判断的，对你来说没有流程差别

### 按照功能划分文件结构

作为一个功能，逻辑，视图，样式，请求等等所有组成部分，应该是一个完整的，不可分割的整体，你才能像搭积木一样工程化地运用它。
如果将其拆开，调试困难，追踪困难的问题，以上提到的可选服务，简单处理嵌套结构都全不成为了不可能
同时，不利于分工合作
每个人都在各自模块下，处理各自问题，顶层组着者再在高层及模块下，将他们组合起来，这是工程化的最优解，这也是 DDD 的核心目标

### 有了 IOC 之后，props 的作用是什么呢？

除了影响调度（函数式组件）外，props 其实在新版 React 中，**只起到 map 节点传递 迭代标示 或者 注入令牌的作用**
通过组件的 props 进行分流（map + key)，能否非常优雅的处理嵌套复杂架构。
状态逻辑一起复用

## 一些东西

调度。
函数是运行时的结构，如果没有利用模式匹配，每次函数执行只有一个结果，那么整个串行函数管道的返回也只会有一个结果如果利用了呢？
它将会向路牌一样，指示着逻辑倒流到特定的lamda函数中，形成分形结构请注意，这个分形结构不只是空间上的，还有时间上的。
这，就是调度！！！

Hooks api 就是 React 的调度控制权
React 将它的调度控制权，拱手交到了用户手上，这就是hooks。

- useState 整个单项数据流的调度发起者
- useEffect 整个单项数据流调度的指挥者
  useEffect 是分形指示器，在 rxjs中被称为 operators,将你的部分变更，衍射到另一处变更。在这个api中，大量模式匹配得以正常工作
- useMemo 整个单项数据流调度的控制者
